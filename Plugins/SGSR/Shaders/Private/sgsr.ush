//============================================================================================================
//
//
//                  Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
//                              SPDX-License-Identifier: BSD-3-Clause
//
//============================================================================================================

///////////////////////////////////////////////////////////////////////////////////////////////////
// SHADER SETUP
///////////////////////////////////////////////////////////////////////////////////////////////////


//#SGSR_TARGET_Definitions -- sync between shader and C++ code
#define SGSR_TARGET_MOBILE 0
#define SGSR_TARGET_HIGH_QUALITY 1
#define SGSR_TARGET_VR 2

/////////////////////////////////////////////
#if defined(SGSR_CPU_CONFIG) // CPU CONFIG //
/////////////////////////////////////////////
	
#ifdef A_HLSL_6_2
	#define SGSR_F1 float32_t
#else
	#define SGSR_F1 float
#endif

#define SGSR_OUT_F4 SGSR_F1 *

SGSR_F1 SGSR_RCP(SGSR_F1 x){return (1.0f/x);}

///////////////////////////////////////////////
#elif defined(SGSR_GPU_CONFIG) // GPU CONFIG //
///////////////////////////////////////////////
#ifdef A_HLSL_6_2
	#define SGSR_F1 float32_t
	#define SGSR_F2 float32_t2
    #define SGSR_F3 float32_t3
	#define SGSR_F4 float32_t4
	#define SGSR_U1 uint32_t
#else
	#define SGSR_F1 float
	#define SGSR_F2 float2
    #define SGSR_F3 float3
	#define SGSR_F4 float4
	#define SGSR_U1 uint
#endif
#if SGSR_USE_HALF_PRECISION
    #if defined(A_HLSL_6_2)
	    #define SGSR_H1 float16_t
	    #define SGSR_H2 float16_t2
	    #define SGSR_H3 float16_t3
	    #define SGSR_H4 float16_t4
    #else
	    #define SGSR_H1 min16float  //half  is interpreted as 32bit float  in UE5.0 -- April, 2023
	    #define SGSR_H2 min16float2 //half2 is interpreted as 32bit float2 in UE5.0 -- April, 2023
	    #define SGSR_H3 min16float3 //half3 is interpreted as 32bit float3 in UE5.0 -- April, 2023
	    #define SGSR_H4 min16float4 //half4 is interpreted as 32bit float4 in UE5.0 -- April, 2023
    #endif
#else
	#define SGSR_H1 SGSR_F1
	#define SGSR_H2 SGSR_F2
	#define SGSR_H3 SGSR_F3
	#define SGSR_H4 SGSR_F4
#endif

#define A_HLSL 1
#if defined(A_HLSL)
    SGSR_H1 SGSR_ARsqH1(SGSR_H1 x){return rsqrt(x);}
    SGSR_H2 SGSR_ARsqH2(SGSR_H2 x){return rsqrt(x);}
    SGSR_H3 SGSR_ARsqH3(SGSR_H3 x){return rsqrt(x);}
    SGSR_H4 SGSR_ARsqH4(SGSR_H4 x){return rsqrt(x);}
#elif defined(A_GLSL)
    SGSR_H1 SGSR_ARsqH1(SGSR_H1 x){return SGSR_H1(1.0)            /  sqrt(x);}
    SGSR_H2 SGSR_ARsqH2(SGSR_H2 x){return SGSR_H2(1.0,1.0)        /  sqrt(x);}
    SGSR_H3 SGSR_ARsqH3(SGSR_H3 x){return SGSR_H3(1.0,1.0,1.0)    /  sqrt(x);}
    SGSR_H4 SGSR_ARsqH4(SGSR_H4 x){return SGSR_H4(1.0,1.0,1.0,1.0)/  sqrt(x);}
#endif

SGSR_H4 SGSR_MH4S(SGSR_H1 a){return SGSR_H4(a,a,a,a);}
#define SGSR_MH1(a) SGSR_H1(a)
#define SGSR_MH4(a) SGSR_MH4S(SGSR_H1(a))

#define SGSR_OUT_F4 out SGSR_F4

SGSR_F1 SGSR_RCP(SGSR_F1 x){return rcp(x);}

Texture2D<SGSR_H4> InputTexture;
RWTexture2D<SGSR_H4> OutputTexture;

SGSR_H4 SGSRRH(SGSR_F2 p)
{	
	SGSR_H4 res = InputTexture.GatherRed(samLinearClamp, p);
	return res;
}

SGSR_H4 SGSRGH(SGSR_F2 p)
{	
	SGSR_H4 res = InputTexture.GatherGreen(samLinearClamp, p);
	return res;
}

SGSR_H4 SGSRBH(SGSR_F2 p)
{	
	SGSR_H4 res = InputTexture.GatherBlue(samLinearClamp, p);
	return res;
}

SGSR_H4 SGSRAH(SGSR_F2 p)
{	SGSR_H4 res = InputTexture.GatherAlpha(samLinearClamp, p);
	return res;
}

SGSR_H4 SGSRRGBH(SGSR_F2 p)
{	SGSR_H4 res = InputTexture.SampleLevel(samLinearClamp, p, 0);
	return res;
}

SGSR_H4 SGSRH(SGSR_F2 p, SGSR_U1 channel) 
{
	if (channel == 0) return  SGSRRH(p);
	if (channel == 1) return  SGSRGH(p);
	if (channel == 2) return  SGSRBH(p);
	return  SGSRAH(p);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
#endif ////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPU / GPU CODE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Call to setup required constant values (works on CPU or GPU).
void SgsrCon(
SGSR_OUT_F4 con0,
SGSR_OUT_F4 con1,
SGSR_F1 inputViewportInPixelsX,
SGSR_F1 inputViewportInPixelsY,
SGSR_F1 inputSizeInPixelsX,
SGSR_F1 inputSizeInPixelsY,
SGSR_F1 outputSizeInPixelsX,
SGSR_F1 outputSizeInPixelsY)
{
	// Output integer position to a pixel position in viewport.
	con0[0] = (inputViewportInPixelsX * SGSR_RCP(outputSizeInPixelsX));
	con0[1] = (inputViewportInPixelsY * SGSR_RCP(outputSizeInPixelsY));
	con0[2] = (SGSR_F1(0.5) * inputViewportInPixelsX * SGSR_RCP(outputSizeInPixelsX) - SGSR_F1(0.5));
	con0[3] = (SGSR_F1(0.5) * inputViewportInPixelsY * SGSR_RCP(outputSizeInPixelsY) - SGSR_F1(0.5));

	// Viewport pixel position to normalized image space.
	// This is used to get upper-left of 'F' tap.
	con1[0] = (SGSR_RCP(inputSizeInPixelsX));
	con1[1] = (SGSR_RCP(inputSizeInPixelsY));

	//make con1.zw as texture size
	con1[2] = SGSR_F1(inputSizeInPixelsX);
	con1[3] = SGSR_F1(inputSizeInPixelsY);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SHADER CODE 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if defined(SGSR_GPU_CONFIG)

/////////SGSR_GL_Mobile.frag/////////////////////////////////////////

#if SGSR_TARGET == SGSR_TARGET_MOBILE
SGSR_H1 fastLanczos2(SGSR_H1 x)
{
	SGSR_H1 wA = x-4.0;
	SGSR_H1 wB = x*wA-wA;
	wA *= wA;
	return wB*wA;
}
SGSR_H2 weightY(SGSR_H1 dx, SGSR_H1 dy, SGSR_H1 c, SGSR_H1 std)
{
	SGSR_H1 x = ((dx*dx)+(dy* dy))* 0.5 + clamp(abs(c)*std, 0.0, 1.0);
	SGSR_H1 w = fastLanczos2(x);
	return SGSR_H2(w, w * c);
}

void SgsrYuvH(
	out SGSR_H4 pix,
	SGSR_F2 uv,
	SGSR_F4 con1)
{
	//int mode = SGSR_MODE;
	SGSR_H1 edgeThreshold = SGSR_EDGE_THRESHOLD;
	SGSR_H1 edgeSharpness = SGSR_EDGE_SHARPNESS;

	//if(mode == 1)
		pix.xyz = SGSRRGBH(uv).xyz;
    //else
	//	pix.xyzw = SGSRRGBH(uv).xyzw;
	SGSR_F1 xCenter;
	xCenter = abs(uv.x+-0.5);
	SGSR_F1 yCenter;
	yCenter = abs(uv.y+-0.5);
	
	//todo5: config the SR region based on needs
    //if ( mode!=4 && xCenter*xCenter+yCenter*yCenter<=0.4 * 0.4)
	//if ( mode!=4)
	{
		SGSR_F2 imgCoord = ((uv.xy*con1.zw)+SGSR_F2(-0.5,0.5));
		SGSR_F2 imgCoordPixel = floor(imgCoord);
		SGSR_F2 coord = (imgCoordPixel*con1.xy);
		SGSR_H2 pl = (imgCoord+(-imgCoordPixel));
		SGSR_H4  left = SGSRGH(coord);//SGSRH(coord, mode);
		
		SGSR_H1 pixLum = pix[1/*mode*/];//luminance approximation
		SGSR_H1 edgeVote = abs(left.z - left.y) + abs(pixLum - left.y)  + abs(pixLum - left.z) ;
		if(edgeVote > edgeThreshold)
		{
			coord.x += con1.x;

			SGSR_H4 right = SGSRGH(coord + SGSR_F2(con1.x,  0.0));//SGSRH(coord + SGSR_F2(con1.x,  0.0), mode);
			SGSR_H4 upDown;
			upDown.xy = SGSRGH(coord + SGSR_F2(0.0, -con1.y)).wz;   //SGSRH(coord + SGSR_F2(0.0, -con1.y), mode).wz;
			upDown.zw = SGSRGH(coord + SGSR_F2(0.0,  con1.y)).yx;   //SGSRH(coord + SGSR_F2(0.0,  con1.y), mode).yx;

			SGSR_H1 mean = (left.y+left.z+right.x+right.w)*SGSR_MH1(0.25);
			left = left - SGSR_MH4(mean);
			right = right - SGSR_MH4(mean);
			upDown = upDown - SGSR_MH4(mean);
			pix.w =pixLum - mean;

			SGSR_H1 sum = (((((abs(left.x)+abs(left.y))+abs(left.z))+abs(left.w))+(((abs(right.x)+abs(right.y))+abs(right.z))+abs(right.w)))+(((abs(upDown.x)+abs(upDown.y))+abs(upDown.z))+abs(upDown.w)));				
			SGSR_H1 std = SGSR_MH1(2.181818)/sum;
			
			SGSR_H2 aWY = weightY(pl.x, pl.y+1.0, upDown.x,std);				
			aWY += weightY(pl.x-1.0, pl.y+1.0, upDown.y,std);
			aWY += weightY(pl.x-1.0, pl.y-2.0, upDown.z,std);
			aWY += weightY(pl.x, pl.y-2.0, upDown.w,std);			
			aWY += weightY(pl.x+1.0, pl.y-1.0, left.x,std);
			aWY += weightY(pl.x, pl.y-1.0, left.y,std);
			aWY += weightY(pl.x, pl.y, left.z,std);
			aWY += weightY(pl.x+1.0, pl.y, left.w,std);
			aWY += weightY(pl.x-1.0, pl.y-1.0, right.x,std);
			aWY += weightY(pl.x-2.0, pl.y-1.0, right.y,std);
			aWY += weightY(pl.x-2.0, pl.y, right.z,std);
			aWY += weightY(pl.x-1.0, pl.y, right.w,std);

			SGSR_H1 finalY = aWY.y/aWY.x;

			SGSR_H1 max4 = max(max(left.y,left.z),max(right.x,right.w));
			SGSR_H1 min4 = min(min(left.y,left.z),min(right.x,right.w));
			finalY = clamp(edgeSharpness*finalY, min4, max4);
					
			SGSR_H1 deltaY = finalY -pix.w;			

			pix.x = saturate((pix.x+deltaY));
			pix.y = saturate((pix.y+deltaY));
			pix.z = saturate((pix.z+deltaY));
		}
	}
	pix.w = 1.0;  //assume alpha channel is not used
}
#endif
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
#if SGSR_TARGET == SGSR_TARGET_HIGH_QUALITY
SGSR_H1 fastLanczos2(SGSR_H1 x)
{
	SGSR_H1 wA = (x + -4.0);
	SGSR_H1 wB = x * wA - wA;
	wA *= wA;
	return wB * wA;
}

SGSR_H4 weightY(SGSR_H1 dx, SGSR_H1 dy, SGSR_H1 c, SGSR_H2 dir, SGSR_H1 std)
{
	SGSR_H1 dxy2 = (dx * dx) + (dy * dy);
	SGSR_H1 c2std = c * c * std;
	
    SGSR_H1 dc = exp(c2std);
	SGSR_H1 ds = sqrt(dxy2);
	
	SGSR_H1 edgeDis = ((dx * dir.y) + (dy * dir.x));
	edgeDis *= edgeDis;
	
    SGSR_H1 x1 = dxy2+(edgeDis * (saturate(c2std*-2.8) * 0.7 + -1.0));
	SGSR_H1 w1 = fastLanczos2(x1);
    
    SGSR_H1 x2 = (ds * 0.54 + 0.36) - dc * 0.36;
	SGSR_H1 w2 = fastLanczos2(x2);

	return SGSR_H4(w1 * c, w1, w2 * c, w2);
}

SGSR_H2 calDirection(SGSR_H4 left, SGSR_H4 right) {
	SGSR_H2 dir;
	SGSR_H1 RxLz = (right.x + (-left.z));
	SGSR_H1 RwLy = (right.w + (-left.y));
	SGSR_H2 delta;
	delta.x = (RxLz + RwLy);
	delta.y = (RxLz + (-RwLy));
	SGSR_H1 lengthInv = SGSR_ARsqH1((delta.x * delta.x+ 3.075740e-05) + (delta.y * delta.y));
	dir.x = (delta.x * lengthInv);
	dir.y = (delta.y * lengthInv);
	return dir;
}

SGSR_H2 sgsrPass(SGSR_H4 left, SGSR_H4 right, SGSR_H4 upDown, SGSR_H2 pl)
{
	SGSR_H1 sum2 = left.x * left.x + left.y * left.y + left.z * left.z + left.w * left.w +
		right.x * right.x + right.y * right.y + right.z * right.z + right.w * right.w +
		upDown.x * upDown.x + upDown.y * upDown.y + upDown.z * upDown.z + upDown.w * upDown.w;
	SGSR_H1 std2 = -6.0 / sum2;


	SGSR_H2 dir = calDirection(left, right);

	SGSR_H4 aYW = weightY(pl.x, pl.y + 1.0, upDown.x, dir, std2);
	aYW += weightY(pl.x - 1.0, pl.y + 1.0, upDown.y, dir, std2);
	aYW += weightY(pl.x - 1.0, pl.y - 2.0, upDown.z, dir, std2);
	aYW += weightY(pl.x, pl.y - 2.0, upDown.w, dir, std2);

	aYW += weightY(pl.x + 1.0, pl.y - 1.0, left.x, dir, std2);
	aYW += weightY(pl.x + 1.0, pl.y, left.w, dir, std2);
	aYW += weightY(pl.x - 2.0, pl.y - 1.0, right.y, dir, std2);
	aYW += weightY(pl.x - 2.0, pl.y, right.z, dir, std2);

	aYW += weightY(pl.x, pl.y - 1.0, left.y, dir, std2);
	aYW += weightY(pl.x, pl.y, left.z, dir, std2);
	aYW += weightY(pl.x - 1.0, pl.y - 1.0, right.x, dir, std2);
	aYW += weightY(pl.x - 1.0, pl.y, right.w, dir, std2);	

	return SGSR_H2(aYW.x / aYW.y, aYW.z / aYW.w);
}

SGSR_H4 textureGatherMode(SGSR_F2 coord/*, int mode*/){
	SGSR_H1 Kr = 0.299;
	SGSR_H1 Kg = 0.587;
	SGSR_H1 Kb = 0.114;
	/*
    if (mode == 2) {
		SGSR_H1 Krg = Kr + Kg;
		Kr = Kr / Krg;
		Kg = Kg / Krg;
	}
    */

	SGSR_H4 left;
	//if (mode == 0)
		//left.xyzw = SGSRH(coord, 0) * SGSR_MH4(Kr)	+ SGSRH(coord, 1) * SGSR_MH4(Kg)	+ SGSRH(coord, 2) * SGSR_MH4(Kb);
        left.xyzw =   SGSRRH(coord)   * SGSR_MH4(Kr)	+ SGSRGH(coord)   * SGSR_MH4(Kg)	+ SGSRBH(coord)   * SGSR_MH4(Kb);
	//else if (mode == 1)
	//	left.xyzw = SGSRH(coord, 1);
	//else if (mode == 2)
	//	left.xyzw = SGSRH(coord, 0) * SGSR_MH4(Kr)	+ SGSRH(coord, 1) * SGSR_MH4(Kg);
	//else 
	//	left.xyzw = SGSRH(coord, 3);
	return left;
}

void SgsrYuvH(
	out SGSR_H4 pix,
	SGSR_F2 uv,
	SGSR_F4 con1){
	//int mode = 0;

	SGSR_H1 edgeThreshold = 4.0 / 255.0;
	SGSR_H1 edgeSharpness = 2.0;

    //if(mode == 1)
	//	pix.xyz = SGSRRGBH(uv).xyz;
	//else
		pix.xyzw = SGSRRGBH(uv).xyzw;
	
	SGSR_H1 Kr = 0.299;
	SGSR_H1 Kg = 0.587;
	SGSR_H1 Kb = 0.114;
    /*
	if (mode == 2) {
		SGSR_H1 Krg = Kr + Kg;
		Kr = Kr / Krg;
		Kg = Kg / Krg;
	}
    */
	//if (mode != 4)
	{
		SGSR_H4 upDown;
		SGSR_H4 right;
		SGSR_H4 left;
		SGSR_H2 pl;
		SGSR_F2 coord;
		SGSR_F2 imgCoord;
		imgCoord.xy = ((uv * con1.zw) + SGSR_H2(-0.5, 0.5));
		SGSR_F2 imgCoordPixel = floor(imgCoord);
		coord.xy = (imgCoordPixel * con1.xy);
		pl.xy = (imgCoord + (-imgCoordPixel));

		left = textureGatherMode(coord/*, mode*/);

		//if (mode == 0)
			pix.w = pix.x * Kr + pix.y * Kg + pix.z * Kb;
		//else if (mode == 1)
		//	pix.w = pix.y;
		//else if (mode == 2)
		//	pix.w = pix.x * Kr + pix.y * Kg ;

		SGSR_H1 edgeVote = abs(left.z - left.y) + abs(pix.w - left.y) + abs(pix.w - left.z);
		if (edgeVote > edgeThreshold) {

			coord.x += con1.x;

			right = textureGatherMode(coord + SGSR_F2(con1.x, 0.0)/*, mode*/);
			upDown.xy = textureGatherMode(coord + SGSR_F2(0.0, -con1.y)/*, mode*/).wz;
			upDown.zw = textureGatherMode(coord + SGSR_F2(0.0, con1.y)/*, mode*/).yx;


			SGSR_H1 mean = ((((left.y + left.z) + right.x) + right.w) * 0.25);
			left.xyzw = left - SGSR_MH4(mean);
			right.xyzw = right - SGSR_MH4(mean);
			upDown.xyzw = upDown - SGSR_MH4(mean);
			pix.w =pix.w - mean;

			SGSR_H2 y2 = sgsrPass(left, right, upDown, pl);

			SGSR_H1 maxY = max(max(left.y, left.z), max(right.x, right.w));
			SGSR_H1 minY = min(min(left.y, left.z), min(right.x, right.w));

			SGSR_H1 edgeY = clamp(edgeSharpness * y2.x, minY, maxY);
			SGSR_H1 smoothY = clamp(edgeSharpness * y2.y, minY, maxY);


			SGSR_H1 deltaY = (smoothY *  0.4- pix.w) + (edgeY * 0.6 );
			pix.x = saturate(pix.x + deltaY);
			pix.y = saturate(pix.y + deltaY);
			pix.z = saturate(pix.z + deltaY);
		}
	}

	pix.w = 1.0;  //assume alpha channel is not used

}
#endif
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
#if SGSR_TARGET == SGSR_TARGET_VR
SGSR_H1 fastLanczos2(SGSR_H1 x)
{
	SGSR_H1 wA = (x + -4.0);
	SGSR_H1 wB = x * wA - wA;
	wA *= wA;
	return wB * wA;
}

SGSR_H2 weightY(SGSR_H1 dx, SGSR_H1 dy,SGSR_H1 c,  SGSR_H2 dir, SGSR_H1 std)
{
	SGSR_H1 edgeDis = ((dx*dir.y)+(dy*dir.x));
	SGSR_H1 x = (((dx*dx)+(dy*dy))+((edgeDis*edgeDis)*((clamp(((c*c)*std),0.0,1.0)*0.7)+-1.0)));

	SGSR_H1 w = fastLanczos2(x);
	return SGSR_H2(w, w * c);
}

SGSR_H2 calDirection(SGSR_H4 left, SGSR_H4 right) {
	SGSR_H2 dir;
	SGSR_H1 RxLz = (right.x + (-left.z));
	SGSR_H1 RwLy = (right.w + (-left.y));
	SGSR_H2 delta;
	delta.x = (RxLz + RwLy);
	delta.y = (RxLz + (-RwLy));
	SGSR_H1 lengthInv = 1/sqrt((delta.x * delta.x+ 3.075740e-05) + (delta.y * delta.y));
	dir.x = (delta.x * lengthInv);
	dir.y = (delta.y * lengthInv);
	return dir;
}

void SgsrYuvH(
	out SGSR_H4 pix,
	SGSR_F2 uv,
	SGSR_F4 con1)
{
	//int mode = 1;                        //todo1: RGBA 1 RGBY 3, LERP 4  manual set this once integration algo is finalized. LERP for quick comparison only
	SGSR_H1 edgeThreshold = 4.0/255.0;     //todo3: config edgeThreshold, 4.0/255 for VR and 8.0/255 for mobile
	SGSR_H1 edgeSharpness = 2.0;           //todo4: config edgeSharpness, suggested range [1.0, 2.0]

	//if(mode == 1)
		pix.xyz = SGSRRGBH(uv).xyz;
	//else
	//	pix.xyzw =SGSRRGBH(uv).xyzw;

	SGSR_F1 xCenter;
	xCenter = abs(uv.x+-0.5);
	SGSR_F1 yCenter;
	yCenter = abs(uv.y+-0.5);

	//todo5: config the SR region based on needs
	//if ( mode!=4 && xCenter*xCenter+yCenter*yCenter<=0.4 * 0.4)
	{
		SGSR_H4 upDown;
		SGSR_H4 right;
		SGSR_H4 left;
		SGSR_H2 pl;
		SGSR_F2 coord;
		SGSR_F2 imgCoord;
		imgCoord.xy = ((uv.xy*con1.zw) + SGSR_F2(-0.5,0.5));
		SGSR_F2 imgCoordPixel = floor(imgCoord);
		coord.xy = (imgCoordPixel*con1.xy);
		pl.xy = (imgCoord+(-imgCoordPixel));
		/*if(mode==1)*/	left.xyzw = SGSRGH(coord);//SGSRH(coord, 1);
		//else left.xyzw = SGSRH(coord, 3);

        SGSR_H1 pixLum = pix[1/*mode*/];//luminance approximation
		SGSR_H1 edgeVote = abs(left.z - left.y) + abs(pixLum - left.y)  + abs(pixLum - left.z) ;
		if(edgeVote > edgeThreshold)
		{
			coord.x += con1.x;

			/*if(mode==1)*/	right.xyzw = SGSRGH(coord + SGSR_F2(con1.x, 0.0));//SGSRH(coord + SGSR_F2(con1.x, 0.0), 1);
			//else right.xyzw = SGSRH(coord + SGSR_F2(con1.x, 0.0), 3);

			/*if(mode==1)*/	upDown.xy = SGSRGH(coord + SGSR_F2(0.0, -con1.y)).wz;//SGSRH(coord + SGSR_F2(0.0, -con1.y),1).wz;
			//else upDown.xy = SGSRH(coord+ SGSR_F2(0.0, -con1.y), 3).wz;

			/*if(mode==1)*/	upDown.zw = SGSRGH(coord + SGSR_F2(0.0, con1.y)).yx;//SGSRH(coord+ SGSR_F2(0.0, con1.y), 1).yx;
			//else upDown.zw  = SGSRH(coord+ SGSR_F2(0.0, con1.y), 3).yx;

			SGSR_H1 mean = ((((left.y+left.z)+right.x)+right.w)*0.25);
			left.xyzw = left - SGSR_MH4(mean);
			right.xyzw = right - SGSR_MH4(mean);
			upDown.xyzw = upDown - SGSR_MH4(mean);
			pix.w = pixLum - mean;
			
			SGSR_H1 sum = (((((abs(left.x)+abs(left.y))+abs(left.z))+abs(left.w))+(((abs(right.x)+abs(right.y))+abs(right.z))+abs(right.w)))+(((abs(upDown.x)+abs(upDown.y))+abs(upDown.z))+abs(upDown.w)));
			SGSR_H1 sumMean = 1.014185e+01/sum;
			SGSR_H1 std = (sumMean*sumMean);	

			SGSR_H2 dir = calDirection(left, right);
		
			SGSR_H2 aWY = weightY(pl.x, pl.y+1.0, upDown.x,dir.xy,std);				
			aWY += weightY(pl.x-1.0, pl.y+1.0, upDown.y,dir.xy,std);
			aWY += weightY(pl.x-1.0, pl.y-2.0, upDown.z,dir.xy,std);
			aWY += weightY(pl.x, pl.y-2.0, upDown.w,dir.xy,std);
			aWY += weightY(pl.x+1.0, pl.y-1.0, left.x,dir.xy,std);
			aWY += weightY(pl.x, pl.y-1.0, left.y,dir.xy,std);
			aWY += weightY(pl.x, pl.y, left.z,dir.xy,std);
			aWY += weightY(pl.x+1.0, pl.y, left.w,dir.xy,std);
			aWY += weightY(pl.x-1.0, pl.y-1.0, right.x,dir.xy,std);
			aWY += weightY(pl.x-2.0, pl.y-1.0, right.y,dir.xy,std);
			aWY += weightY(pl.x-2.0, pl.y, right.z,dir.xy,std);
			aWY += weightY(pl.x-1.0, pl.y, right.w,dir.xy,std);
			

			SGSR_H1 finalY = aWY.y/aWY.x;
			SGSR_H1 maxY = max(max(left.y,left.z),max(right.x,right.w));
			SGSR_H1 minY = min(min(left.y,left.z),min(right.x,right.w));				
					
			SGSR_H1 deltaY = clamp(edgeSharpness*finalY, minY, maxY) -pix.w;			

			//smooth high contrast input
			deltaY = clamp(deltaY, -23.0 / 255.0, 23.0 / 255.0);
			
			pix.x = clamp((pix.x+deltaY),0.0,1.0);
			pix.y = clamp((pix.y+deltaY),0.0,1.0);
			pix.z = clamp((pix.z+deltaY),0.0,1.0);
		}
	}

	pix.w = 1.0;  //assume alpha channel is not used
}
#endif
////////////////////////////////////////////////////////////////////////

#endif