//============================================================================================================
//
//
//                  Copyright (c) 2024, Qualcomm Innovation Center, Inc. All rights reserved.
//                              SPDX-License-Identifier: BSD-3-Clause
//
//============================================================================================================

#include "gsr_common.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// =====================================================================================
//
// SHADER RESOURCES
//
// =====================================================================================
Texture2D<float4> InputColor;
Texture2D<float4> MotionDepthClipAlphaBuffer;
Texture2D<float4> PrevHistoryOutput;

SamplerState PointClamp;
SamplerState LinearClamp1;
SamplerState LinearClamp2;
uint bSameCamera;
float Exposure_co_rcp;
float ValidReset;
float MinLerpContribution; // 0.0 or 0.3, when camera move 0.0, camera freeze 0.3
float Scalefactor;
float Biasmax_viewportXScale;

// =====================================================================================
// 
// SNAPDRAGON GAME SUPER RESOLUTION
// 
// =====================================================================================

float FastLanczos(float base)
{
    float y = base - 1.0f;
    float y2 = y * y;
    float y_temp = 0.75f * y + y2;
    return y_temp * y2;
}

// =====================================================================================
//
// ENTRY POINTS
//
// =====================================================================================
void MainPS(noperspective float4 UVAndScreenPos : TEXCOORD0, float4 SvPosition : SV_POSITION, out float4 OutColor : SV_Target0)
{
    //Prepare UV
    float2 Hruv = SvPosition.xy * OutputInfo_ViewportSizeInverse;
    float2 Jitteruv;
    Jitteruv.x = saturate(Hruv.x + InputJitter.x * InputInfo_ViewportSizeInverse.x);
    Jitteruv.y = saturate(Hruv.y + InputJitter.y * InputInfo_ViewportSizeInverse.y);
    
    int2 InputPos = int2(Hruv * InputInfo_ViewportSize);
    half3 mda = half3(MotionDepthClipAlphaBuffer.SampleLevel(LinearClamp1, Jitteruv, 0).xyz);
    float2 PrevUV;
    PrevUV.x = -0.5f * mda.x + Hruv.x;
    PrevUV.y = 0.5f * mda.y + Hruv.y;
    PrevUV.x = clamp(PrevUV.x, 0.0f, 1.0f);
    PrevUV.y = clamp(PrevUV.y, 0.0f, 1.0f);
    
    half depthclip = mda.z;
    half3 HistoryColor = PrevHistoryOutput.SampleLevel(LinearClamp2, PrevUV, 0).xyz;

	//Upsample and Compute box
    half4 Upsampledcw = half4(0.0f, 0.0f, 0.0f, 0.0f);
    half kernelfactor = ValidReset;
    half biasmax = Biasmax_viewportXScale;
    half biasmin = max(1.0f, 0.3f + 0.3f * biasmax);
    half biasfactor = max(0.25f * depthclip, kernelfactor);
    half kernelbias = lerp(biasmax, biasmin, biasfactor);
    half motion_viewport_len = length(mda.xy * OutputInfo_ViewportSize);
    half curvebias = lerp(-2.0f, -3.0f, saturate(motion_viewport_len * 0.02f /* / 50.0f*/));

    float3 rectboxcenter = float3(0.0f, 0.0f, 0.0f);
    float3 rectboxvar = float3(0.0f, 0.0f, 0.0f);
    float rectboxweight = 0.0f;

    float2 srcpos = float2(InputPos) + float2(0.5f, 0.5f) - InputJitter;
    kernelbias *= 0.5f;
    float kernelbias2 = kernelbias * kernelbias;
    float2 srcpos_srcOutputPos = srcpos - Hruv * InputInfo_ViewportSize;
    
    half3 rectboxmin;
    half3 rectboxmax;
    half3 topMid = half3(InputColor[InputPos + int2(0, 1)].xyz);
	{ 
        half3 samplecolor = topMid;
        half2 baseoffset = srcpos_srcOutputPos + half2(0.0f, 1.0f);
        half baseoffset_dot = dot(baseoffset, baseoffset);
        half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        half weight = FastLanczos(base);
        Upsampledcw += half4(samplecolor * weight, weight);
        half boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = samplecolor;
        rectboxmax = samplecolor;
        half3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    half3 rightMid = half3(InputColor[InputPos + int2(1, 0)].xyz);
	{
        half3 samplecolor = rightMid;
        half2 baseoffset = srcpos_srcOutputPos + half2(1.0f, 0.0f);
        half baseoffset_dot = dot(baseoffset, baseoffset);
        half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        half weight = FastLanczos(base);
        Upsampledcw += half4(samplecolor * weight, weight);
        half boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        half3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    half3 leftMid = half3(InputColor[InputPos + int2(-1, 0)].xyz);
	{
        half3 samplecolor = leftMid;
        half2 baseoffset = srcpos_srcOutputPos + half2(-1.0f, 0.0f);
        half baseoffset_dot = dot(baseoffset, baseoffset);
        half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        half weight = FastLanczos(base);
        Upsampledcw += half4(samplecolor * weight, weight);
        half boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        half3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    half3 centerMid = half3(InputColor[InputPos].xyz);
	{
        half3 samplecolor = centerMid;
        half2 baseoffset = srcpos_srcOutputPos;
        half baseoffset_dot = dot(baseoffset, baseoffset);
        half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        half weight = FastLanczos(base);
        Upsampledcw += half4(samplecolor * weight, weight);
        half boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        half3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    half3 btmMid = half3(InputColor[InputPos + int2(0, -1)].xyz);
	{
        half3 samplecolor = btmMid;
        half2 baseoffset = srcpos_srcOutputPos + half2(0.0f, -1.0f);
        half baseoffset_dot = dot(baseoffset, baseoffset);
        half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        half weight = FastLanczos(base);
        Upsampledcw += half4(samplecolor * weight, weight);
        half boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        half3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    //if (bSameCamera != 0) //maybe disable this for ultra performance
    if (false)  //maybe disable this for ultra performance, true could generate more realistic output
    {
		{
            half3 samplecolor = half3(InputColor[InputPos + int2(1, 1)].xyz);
            half2 baseoffset = srcpos_srcOutputPos + half2(1.0f, 1.0f);
            half baseoffset_dot = dot(baseoffset, baseoffset);
            half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
            half weight = FastLanczos(base);
            Upsampledcw += half4(samplecolor * weight, weight);
            half boxweight = exp(baseoffset_dot * curvebias);
            rectboxmin = min(rectboxmin, samplecolor);
            rectboxmax = max(rectboxmax, samplecolor);
            half3 wsample = samplecolor * boxweight;
            rectboxcenter += wsample;
            rectboxvar += (samplecolor * wsample);
            rectboxweight += boxweight;
        }
		{
            half3 samplecolor = half3(InputColor[InputPos + int2(-1, 1)].xyz);
            half2 baseoffset = srcpos_srcOutputPos + half2(-1.0f, 1.0f);
            half baseoffset_dot = dot(baseoffset, baseoffset);
            half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
            half weight = FastLanczos(base);
            Upsampledcw += half4(samplecolor * weight, weight);
            half boxweight = exp(baseoffset_dot * curvebias);
            rectboxmin = min(rectboxmin, samplecolor);
            rectboxmax = max(rectboxmax, samplecolor);
            half3 wsample = samplecolor * boxweight;
            rectboxcenter += wsample;
            rectboxvar += (samplecolor * wsample);
            rectboxweight += boxweight;
        }
		{
            half3 samplecolor = half3(InputColor[InputPos + int2(1, -1)].xyz);
            half2 baseoffset = srcpos_srcOutputPos + half2(1.0f, -1.0f);
            half baseoffset_dot = dot(baseoffset, baseoffset);
            half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
            half weight = FastLanczos(base);
            Upsampledcw += half4(samplecolor * weight, weight);
            half boxweight = exp(baseoffset_dot * curvebias);
            rectboxmin = min(rectboxmin, samplecolor);
            rectboxmax = max(rectboxmax, samplecolor);
            half3 wsample = samplecolor * boxweight;
            rectboxcenter += wsample;
            rectboxvar += (samplecolor * wsample);
            rectboxweight += boxweight;
        }
		{
            half3 samplecolor = half3(InputColor[InputPos + int2(-1, -1)].xyz);
            half2 baseoffset = srcpos_srcOutputPos + half2(-1.0f, -1.0f);
            half baseoffset_dot = dot(baseoffset, baseoffset);
            half base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
            half weight = FastLanczos(base);
            Upsampledcw += half4(samplecolor * weight, weight);
            half boxweight = exp(baseoffset_dot * curvebias);
            rectboxmin = min(rectboxmin, samplecolor);
            rectboxmax = max(rectboxmax, samplecolor);
            half3 wsample = samplecolor * boxweight;
            rectboxcenter += wsample;
            rectboxvar += (samplecolor * wsample);
            rectboxweight += boxweight;
        }
    }
    rectboxweight = 1.0f / rectboxweight;
    rectboxcenter *= rectboxweight;
    rectboxvar *= rectboxweight;
    rectboxvar = sqrt(abs(rectboxvar - rectboxcenter * rectboxcenter));
    
    half3 bias = half3(0.05f, 0.05f, 0.05f);
    
    Upsampledcw.xyz = clamp(Upsampledcw.xyz / Upsampledcw.w, rectboxmin - bias, rectboxmax + bias);
    Upsampledcw.w = Upsampledcw.w * (1.0f / 3.0f);

    half baseupdate = 1.0f - depthclip;
    baseupdate = min(baseupdate, lerp(baseupdate, Upsampledcw.w * 10.0f, saturate(10.0f * motion_viewport_len)));
    baseupdate = min(baseupdate, lerp(baseupdate, Upsampledcw.w, saturate(motion_viewport_len * 0.05f)));
    half basealpha = baseupdate;

    const float EPSILON = 1.192e-07f /*1.192092896e-07f*/;
    half boxscale = max(depthclip, saturate(motion_viewport_len * 0.05f));
    half boxsize = lerp(Scalefactor, 1.0f, boxscale);

    half3 sboxvar = rectboxvar * boxsize;
    half3 boxmin = rectboxcenter - sboxvar;
    half3 boxmax = rectboxcenter + sboxvar;
    rectboxmax = min(rectboxmax, boxmax);
    rectboxmin = max(rectboxmin, boxmin);

    half3 clampedcolor = clamp(HistoryColor, rectboxmin, rectboxmax);
    half startLerpValue = MinLerpContribution;
    if ((abs(mda.x) + abs(mda.y)) > 0.000001)
        startLerpValue = 0.0;
    half lerpcontribution = (any(rectboxmin > HistoryColor) || any(HistoryColor > rectboxmax)) ? startLerpValue : 1.0f;

    HistoryColor = lerp(clampedcolor, HistoryColor, saturate(lerpcontribution));
    half basemin = min(basealpha, 0.1f);
    basealpha = lerp(basemin, basealpha, saturate(lerpcontribution));

	//Blend Color
    half alphasum = max(EPSILON, basealpha + Upsampledcw.w);
    half alpha = saturate(Upsampledcw.w / alphasum + ValidReset);

    Upsampledcw.xyz = lerp(HistoryColor, Upsampledcw.xyz, alpha.xxx);
    Upsampledcw.xyz = clamp(Upsampledcw.xyz, rectboxmin, rectboxmax);
    OutColor = Upsampledcw.xyzw;
}